---
title: git

date: 2020-11-27 19:16:03

tags: 
	- git
	- 常用笔记

mathjax: true

categories: 
	- 常用笔记
---

# 版本控制

## 1. 自己的多个版本所有保存

## 2. 团队协作中可以同时修改一个文件，不会产生文件冲突

## 3. 应该具备的功能:
1. 协同修改
2. 数据备份
3. 版本控制
	* **SVN** 采用增量式管理
	* **Git** 采取文件系统的快照
4. 权限控制
	* 对团队内的成员权限控制
	* 对团队外的的成员贡献的代码审核 (**Git** 独有)
5. 历史记录
	* 查看修改的记录
6. 分支管理
	* 多条生产线同时推进内容

<!--more-->

## 4.版本控制软件
1. 集中式的版本控制工具 **CVS**,(要在 **服务器** 进行版本控制,存在 **单点故障**)
2. 分布式的版本控制工具 **Git**, **Mercurial**, **Bazaar**, **Darcs**(能在 **本地**进行版本控制,避免了 **单点故障**)


# Git 

## 1.git的优势
* 大部分操作在本地完成，不需要联网
* 完整性保证
* 尽可能添加数据而不是删除或修改数据
* 分支操作非常快捷流畅
* 与Linux命令全面兼容

## 2.git的结构
1. 工作区 (如写代码)
2. 暂存区 (临时存储)
3. 本地库 (历史版本)

4. 流程:
**工作区**--`git add` -> **暂存区**  --`git commit` -> **本地库**

## 3.代码托管中心(维护远程库)
1. 局域网下: GitLab
2. 外网:GitHub,码云

## 本地库和远程库
1. 团队内部协作
	* 团队成员A 创建远程库后: 
		* **本地库** -- `push`  -> **远程库**
	* 用户B 克隆远程库到本地: 
		* **远程库** -- `clone` -> **本地户** 
	* 邀请 <u>**加入团队**</u>后的用户B可以:
		* **本地库** -- `push` -> **远程库**
	* 团队成员A拉取更新B的分支
		* **远程库** -- `pull` -> **本地库**
	
2. 跨团队协作
	* 团队A 复制(`fork`)一份远程库给 团队B
	* 团队B 修改自己的远程库
	* 团队A `pull request` 团队B的远程库后 通过审核 `merge` 到自己的远程库 

## git 操作

### 本地库初始化
#### 1. 命令: 
* `git init` 初始化一个git目录 (.git 目录是存放本地库的相关文件的目录)
#### 2. 设置签名: 
* 形式： 
	1. 用户名: userName
	2.  Email地址: emailName@email.com
* 作用： 区分不同开发人员的身份
* 备注：　用户名与远程托管中心没有关系
* 命令:
	1. **项目**级别/ **仓库**级别：
		* `git config user.name userName`　
		* `git config user.email emailName@email.com`　
		* 仅在当前本地库范围内有效
		* **保存**在　当前目录的 ./.git/config
	2. **系统**用户级别:
		* `git config --golbal user.name userName` 
		* `git config --golbal user.email emailName@email.com`　
		* 登陆当前操作系统的用户范围
		* 保存在　~/.gitconfig
	3. 级别优先级：　就近原则, 项目级别大于系统用户级别(不允许二者都没有)

### 基本操作
1. 状态查看:　`git status`
2. 添加操作: `git add [fileName]`    提交到 **暂存库**
3. 提交操作: 
	* `git commit [fileName]` 提交到 **本地库** 会打开编辑器写 修改备注
	* `git commit -m "commit message" [File Name]` 不会打开编辑器
4. 查看历史记录
	* `git log` : 完整详细显示
	* `git log --pretty=oneline`: 一行显示(完整哈希, commit备注内容)
	* `git log --oneline`: 一行显示(简略哈希, commit备注内容)
	* `git reflog` : 显示到某一个版本的步数
5. 版本前进后退 **reset**
	* 基于索引值操作[推荐]
		* `git reset --hard [索引值(部分哈希值)]`
		* 如：　 `git reset --hard bee423d`
	* 使用^ 符号 (只能往后退)
		* `git reset --hard HEAD^`
		* 注：　一个^后退一部，ｎ个^后退ｎ步
	* 使用～符号 (只能往后退)
		* `git reset --hard HEAD~n`
		* 注：　表示后退ｎ步
	* **reset** 的三个参数: 
		* `--soft` 参数: 仅仅在 **本地库** 移动HEAD指针
			* 这时候<u>**暂存区**</u>和<u>**工作区**</u>就**相对**较新了
		* `--mixed`参数: 在本地库移动HEAD指针 、 重置暂存区
			* 这时候<u>**工作区**</u>就**相对**较新了
		* `--hard` 参数: 在本地库移动HEAD指针 、 重置暂存区 、重置工作区
6. 删除文件找回
	* 前提: 删除前，文件存在时的状态提交到本地库
	* 操作:	`git reset --hard[指针位置]`
		* 删除操作已经提交到本地库： 指针位置指向历史记录
		* 删除操作尚未提交到本地库： 指针位置指向HEAD
7. 比较文件操作
	* `git diff [文件名]` 将工作区中的文件和暂存区进行比较
	* `git diff [某个历史版本] [文件名] ` 将工作区中的文件和本地库比较
	* 不带文件名，所有文件都比较


### 分支管理

#### 1. 什么是分支: 
	* 在版本控制过程中，使用多条线同时推进多个任务
#### 2. 分支的好处: 
	* 同时并行推进多个功能开发，提高开发效率
	* 各个分支在开发的过程中，如果一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开发即可。

#### 3. 分支操作
1. 创建分支:`git branch [分支名]`
2. 查看分支:`git branch -v`
3. 切换分支:`git checkout [分支名]`
4. 合并分支:
	* 第一步： 切换到要接受修改的分支 (被合并,增加新内容)
		* `git check out [被合并的分支名]`
	* 第二步： 执行 merge 命令
		* `git merge [有新内容的分支名]`
5. 冲突: 
	* 冲突的表现:   
![冲突表现](picture/1.png)
	* 冲突的解决：
		1. 编辑文件，删除特殊符号
		2. 把文件修改到满意的程度，保存退出
		3. `git add [文件名]`
		4. `git commit -m "日志信息" ` 注： **不需要**带文件名

## Git 保存版本的机制

## GitHub  远程仓库

### 1. remote 别名 
1. 列出所有仓库别名
	* `git remote`
2. 列出所有仓库别名和对应的地址
	* `git remote -v`
3. 给仓库取别名
	* `git remote add [别名] [仓库地址]`
4. 删除别名
	* `git remote rm [别名]`
5. 重命名
	* `git remote rename [旧别名] [新别名]`

### 2. clone 克隆 
1. `git clone <版本库的地址>`

### 3. fetch 
1. `git fetch <远程主机名>`  默认取回所有分支
2. `git fetch <远程主机名><分支名>` 取回特定分支 

### 4. pull
1. `git pull <远程主机名> <远程分支名>:<本地分支名>` 取回远程的某个分支再与本地分支合并 
	* 如： `git pull origin next:master ` 取回origin主机的next分支，与本地的master分支合并
	* 与当前分支合并可以省略冒号后面的部分
2. 相当于 `git fetch <远程主机名>` 再 `git merge `



